# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:46:11+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    ApplicationsApplicationPatchRequest,
    ApplicationsPostRequest,
    AssociateAttributeGroupResponse,
    AssociateResourceResponse,
    AttributeGroupsAttributeGroupPatchRequest,
    AttributeGroupsPostRequest,
    ConfigurationPutRequest,
    ConflictException,
    CreateApplicationResponse,
    CreateAttributeGroupResponse,
    DeleteApplicationResponse,
    DeleteAttributeGroupResponse,
    DisassociateAttributeGroupResponse,
    DisassociateResourceResponse,
    GetApplicationResponse,
    GetAssociatedResourceResponse,
    GetAttributeGroupResponse,
    GetConfigurationResponse,
    InternalServerException,
    ListApplicationsResponse,
    ListAssociatedAttributeGroupsResponse,
    ListAssociatedResourcesResponse,
    ListAttributeGroupsForApplicationResponse,
    ListAttributeGroupsResponse,
    ListTagsForResourceResponse,
    ResourceNotFoundException,
    ResourceType,
    ServiceQuotaExceededException,
    SyncResourceResponse,
    TagKeys,
    TagResourceResponse,
    TagsResourceArnPostRequest,
    ThrottlingException,
    UntagResourceResponse,
    UpdateApplicationResponse,
    UpdateAttributeGroupResponse,
    ValidationException,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description=' Amazon Web Services Service Catalog AppRegistry enables organizations to understand the application context of their Amazon Web Services resources. AppRegistry provides a repository of your applications, their resources, and the application metadata that you use within your enterprise.',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS Service Catalog App Registry',
    version='2020-06-24',
    servers=[
        {
            'description': 'The AppRegistry multi-region endpoint',
            'url': 'http://servicecatalog-appregistry.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AppRegistry multi-region endpoint',
            'url': 'https://servicecatalog-appregistry.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AppRegistry endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://servicecatalog-appregistry.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AppRegistry endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://servicecatalog-appregistry.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/applications',
    description=""" Retrieves a list of all of your applications. Results are paginated. """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_applications(
    next_token: Optional[
        constr(pattern=r'[A-Za-z0-9+/=]+', min_length=1, max_length=2024)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications',
    description=""" Creates a new application that is the top-level node in a hierarchy of related cloud resource abstractions. """,
    tags=['application_management', 'resource_linking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_application(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{application}',
    description=""" Deletes an application that is specified either by its application ID, name, or ARN. All associated attribute groups and resources must be disassociated from it before deleting an application. """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_application(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{application}',
    description="""  Retrieves metadata information about one of your applications. The application can be specified by its ARN, ID, or name (which is unique within one account in one region at a given point in time). Specify by ARN or ID in automated workflows if you want to make sure that the exact same application is returned or a <code>ResourceNotFoundException</code> is thrown, avoiding the ABA addressing problem.  """,
    tags=['application_management', 'resource_linking', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_application(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/applications/{application}',
    description=""" Updates an existing application with new attributes. """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_application(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{application}/attribute-group-details',
    description=""" Lists the details of all attribute groups associated with a specific application. The results display in pages. """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_attribute_groups_for_application(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    next_token: Optional[
        constr(pattern=r'[A-Za-z0-9+/=]+', min_length=1, max_length=2024)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{application}/attribute-groups',
    description=""" Lists all attribute groups that are associated with specified application. Results are paginated. """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_associated_attribute_groups(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    next_token: Optional[
        constr(pattern=r'[A-Za-z0-9+/=]+', min_length=1, max_length=2024)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{application}/attribute-groups/{attributeGroup}',
    description=""" Disassociates an attribute group from an application to remove the extra attributes contained in the attribute group from the application's metadata. This operation reverts <code>AssociateAttributeGroup</code>. """,
    tags=['application_management', 'attribute_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_attribute_group(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    attribute_group: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/attribute-groups/[-.\w]+)',
        min_length=1,
        max_length=512,
    ) = Path(..., alias='attributeGroup'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/applications/{application}/attribute-groups/{attributeGroup}',
    description=""" Associates an attribute group with an application to augment the application's metadata with the group's attributes. This feature enables applications to be described with user-defined details that are machine-readable, such as third-party integrations. """,
    tags=['application_management', 'attribute_management', 'resource_linking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_attribute_group(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    attribute_group: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/attribute-groups/[-.\w]+)',
        min_length=1,
        max_length=512,
    ) = Path(..., alias='attributeGroup'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{application}/resources',
    description=""" <p> Lists all of the resources that are associated with the specified application. Results are paginated. </p> <note> <p> If you share an application, and a consumer account associates a tag query to the application, all of the users who can access the application can also view the tag values in all accounts that are associated with it using this API. </p> </note> """,
    tags=['application_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_associated_resources(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    next_token: Optional[
        constr(pattern=r'[A-Za-z0-9+/=]+', min_length=1, max_length=2024)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{application}/resources/{resourceType}/{resource}',
    description=""" Disassociates a resource from application. Both the resource and the application can be specified either by ID or name. """,
    tags=['application_management', 'resource_linking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_resource(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    resource_type: ResourceType = Path(..., alias='resourceType'),
    resource: constr(pattern=r'\S+', min_length=1, max_length=256) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{application}/resources/{resourceType}/{resource}',
    description=""" Gets the resource associated with the application. """,
    tags=['application_management', 'resource_linking', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_associated_resource(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    resource_type: ResourceType = Path(..., alias='resourceType'),
    resource: constr(pattern=r'\S+', min_length=1, max_length=256) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/applications/{application}/resources/{resourceType}/{resource}',
    description="""  Associates a resource with an application. The resource can be specified by its ARN or name. The application can be specified by ARN, ID, or name.  """,
    tags=['application_management', 'resource_linking', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_resource(
    application: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/applications/[-.\w]+)',
        min_length=1,
        max_length=256,
    ),
    resource_type: ResourceType = Path(..., alias='resourceType'),
    resource: constr(pattern=r'\S+', min_length=1, max_length=256) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/attribute-groups',
    description=""" Lists all attribute groups which you have access to. Results are paginated. """,
    tags=['configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_attribute_groups(
    next_token: Optional[
        constr(pattern=r'[A-Za-z0-9+/=]+', min_length=1, max_length=2024)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/attribute-groups',
    description=""" Creates a new attribute group as a container for user-defined attributes. This feature enables users to have full control over their cloud application's metadata in a rich machine-readable format to facilitate integration with automated workflows and third-party tools. """,
    tags=['attribute_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_attribute_group(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AttributeGroupsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/attribute-groups/{attributeGroup}',
    description=""" Deletes an attribute group, specified either by its attribute group ID, name, or ARN. """,
    tags=['attribute_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_attribute_group(
    attribute_group: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/attribute-groups/[-.\w]+)',
        min_length=1,
        max_length=512,
    ) = Path(..., alias='attributeGroup'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/attribute-groups/{attributeGroup}',
    description="""  Retrieves an attribute group by its ARN, ID, or name. The attribute group can be specified by its ARN, ID, or name.  """,
    tags=['attribute_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_attribute_group(
    attribute_group: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/attribute-groups/[-.\w]+)',
        min_length=1,
        max_length=512,
    ) = Path(..., alias='attributeGroup'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/attribute-groups/{attributeGroup}',
    description=""" Updates an existing attribute group with new details.  """,
    tags=['attribute_management', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_attribute_group(
    attribute_group: constr(
        pattern=r'([-.\w]+)|(arn:aws[-a-z]*:servicecatalog:[a-z]{2}(-gov)?-[a-z]+-\d:\d{12}:/attribute-groups/[-.\w]+)',
        min_length=1,
        max_length=512,
    ) = Path(..., alias='attributeGroup'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AttributeGroupsAttributeGroupPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/configuration',
    description="""  Retrieves a <code>TagKey</code> configuration from an account.  """,
    tags=['configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_configuration(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/configuration',
    description="""  Associates a <code>TagKey</code> configuration to an account.  """,
    tags=['configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_configuration(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ConfigurationPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sync/{resourceType}/{resource}',
    description=""" <p>Syncs the resource with current AppRegistry records.</p> <p>Specifically, the resource’s AppRegistry system tags sync with its associated application. We remove the resource's AppRegistry system tags if it does not associate with the application. The caller must have permissions to read and update the resource.</p> """,
    tags=['resource_linking', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def sync_resource(
    resource_type: ResourceType = Path(..., alias='resourceType'),
    resource: constr(pattern=r'\S+', min_length=1, max_length=256) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{resourceArn}',
    description=""" Lists all of the tags on the resource. """,
    tags=['resource_linking', 'configuration_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)',
        min_length=1,
        max_length=1600,
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{resourceArn}',
    description=""" <p>Assigns one or more tags (key-value pairs) to the specified resource.</p> <p>Each tag consists of a key and an optional value. If a tag with the same key is already associated with the resource, this action updates its value.</p> <p>This operation returns an empty response if the call was successful.</p> """,
    tags=['resource_linking', 'tagging_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)',
        min_length=1,
        max_length=1600,
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{resourceArn}#tagKeys',
    description=""" <p>Removes tags from a resource.</p> <p>This operation returns an empty response if the call was successful.</p> """,
    tags=['tagging_operations', 'resource_linking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)',
        min_length=1,
        max_length=1600,
    ) = Path(..., alias='resourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
